name: Update Single Driver Data

on:
  workflow_call:
    inputs:
      driver_name:
        required: true
        type: string
      driver_display_name:
        required: true
        type: string
      repo_name:
        required: true
        type: string
      force_recreate:
        required: false
        type: boolean
        default: false
    outputs:
      updated:
        description: "Whether the driver data was updated"
        value: ${{ jobs.update-driver.outputs.updated }}
      latest_version:
        description: "Latest version found"
        value: ${{ jobs.update-driver.outputs.latest_version }}

jobs:
  update-driver:
    runs-on: ubuntu-latest
    outputs:
      updated: ${{ steps.check_changes.outputs.has_changes }}
      latest_version: ${{ steps.update.outputs.latest_version }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'

    - name: Create update script
      run: |
        cat > update_driver.js << 'EOF'
        const fs = require('fs');
        const https = require('https');

        // Configuration
        const DRIVER_NAME = process.env.DRIVER_NAME;
        const DRIVER_DISPLAY_NAME = process.env.DRIVER_DISPLAY_NAME;
        const REPO_NAME = process.env.REPO_NAME;
        const FORCE_RECREATE = process.env.FORCE_RECREATE === 'true';
        const DATA_FILE = `data/${DRIVER_NAME}.json`;
        const GITHUB_OUTPUT = process.env.GITHUB_OUTPUT;

        console.log(`Updating ${DRIVER_DISPLAY_NAME} driver data...`);
        console.log(`Repository: ${REPO_NAME}`);
        console.log(`Force recreate: ${FORCE_RECREATE}`);

        // Helper function to write GitHub Actions output
        function writeOutput(key, value) {
          if (GITHUB_OUTPUT) {
            fs.appendFileSync(GITHUB_OUTPUT, `${key}=${value}\n`);
          }
        }

        // Helper function to make HTTP requests with retry logic
        function httpsGet(url, retries = 3) {
          return new Promise((resolve, reject) => {
            const attempt = (attemptsLeft) => {
              const options = {
                headers: {
                  'User-Agent': 'MongoDB-Driver-Compatibility-Checker/1.0',
                  'Accept': 'application/vnd.github.v3+json',
                  'X-GitHub-Api-Version': '2022-11-28'
                }
              };

              https.get(url, options, (res) => {
                let data = '';
                res.on('data', chunk => data += chunk);
                res.on('end', () => {
                  if (res.statusCode === 200) {
                    try {
                      resolve(JSON.parse(data));
                    } catch (e) {
                      reject(new Error(`Failed to parse JSON: ${e.message}`));
                    }
                  } else if (res.statusCode === 403 && attemptsLeft > 0) {
                    console.log(`Rate limited, retrying in 60 seconds... (${attemptsLeft} attempts left)`);
                    setTimeout(() => attempt(attemptsLeft - 1), 60000);
                  } else {
                    reject(new Error(`HTTP ${res.statusCode}: ${data}`));
                  }
                });
              }).on('error', (err) => {
                if (attemptsLeft > 0) {
                  console.log(`Request failed, retrying... (${attemptsLeft} attempts left):`, err.message);
                  setTimeout(() => attempt(attemptsLeft - 1), 5000);
                } else {
                  reject(err);
                }
              });
            };

            attempt(retries);
          });
        }

        // Function to get all releases from GitHub API
        async function getAllReleases() {
          console.log('Fetching releases from GitHub API...');
          let allReleases = [];
          let page = 1;
          const perPage = 100;

          while (true) {
            const url = `https://api.github.com/repos/${REPO_NAME}/releases?page=${page}&per_page=${perPage}`;
            console.log(`Fetching page ${page}...`);

            try {
              const releases = await httpsGet(url);
              if (releases.length === 0) break;

              allReleases = allReleases.concat(releases);
              page++;

              // Rate limiting - wait between requests
              if (page > 1) {
                await new Promise(resolve => setTimeout(resolve, 2000));
              }

              // Prevent infinite loops
              if (page > 50) {
                console.log('Reached maximum page limit (50), stopping...');
                break;
              }
            } catch (error) {
              console.error(`Error fetching page ${page}:`, error.message);
              if (error.message.includes('HTTP 403')) {
                console.log('Rate limit exceeded, using existing releases...');
                break;
              }
              throw error;
            }
          }

          console.log(`Found ${allReleases.length} total releases`);
          return allReleases;
        }

        // Function to validate semantic version
        function isValidSemver(version) {
          const semverRegex = /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/;
          return semverRegex.test(version);
        }

        // Function to compare semantic versions
        function compareVersions(a, b) {
          const parseVersion = (v) => {
            const parts = v.split('-')[0].split('.').map(n => parseInt(n, 10));
            return parts;
          };

          const aParts = parseVersion(a);
          const bParts = parseVersion(b);

          for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {
            const aPart = aParts[i] || 0;
            const bPart = bParts[i] || 0;
            if (aPart !== bPart) return bPart - aPart;
          }
          return 0;
        }

        // Function to filter and format releases
        function processReleases(releases) {
          const processed = releases
            .filter(release => {
              // Skip prerelease, draft, and invalid releases
              if (release.prerelease || release.draft) return false;
              if (!release.published_at) return false;

              // Clean version string
              const version = release.tag_name.replace(/^[v]/, '');
              return isValidSemver(version);
            })
            .map(release => ({
              version: release.tag_name.replace(/^[v]/, ''),
              releaseDate: release.published_at.split('T')[0],
              originalTag: release.tag_name
            }))
            .sort((a, b) => compareVersions(a.version, b.version));

          console.log(`Processed ${processed.length} valid releases from ${releases.length} total`);
          return processed;
        }

        // Main execution
        async function main() {
          try {
            // Read existing data
            let existingData = {
              driver: DRIVER_DISPLAY_NAME,
              repository: `https://github.com/${REPO_NAME}`,
              versions: []
            };

            if (fs.existsSync(DATA_FILE) && !FORCE_RECREATE) {
              const fileContent = fs.readFileSync(DATA_FILE, 'utf8');
              existingData = JSON.parse(fileContent);
              console.log(`Existing data has ${existingData.versions.length} versions`);
              console.log(`Latest existing version: ${existingData.versions[0]?.version || 'none'}`);
            } else {
              console.log(FORCE_RECREATE ? 'Force recreating data file...' : 'No existing data file found');
            }

            // Fetch releases from GitHub
            const releases = await getAllReleases();
            if (releases.length === 0) {
              console.log('No releases found from API');
              process.exit(0);
            }

            const processedReleases = processReleases(releases);
            if (processedReleases.length === 0) {
              console.log('No valid releases found after processing');
              process.exit(0);
            }

            console.log(`Latest release: ${processedReleases[0].version} (${processedReleases[0].releaseDate})`);

            // Check if update is needed
            let needsUpdate = FORCE_RECREATE;

            if (!FORCE_RECREATE && existingData.versions.length > 0) {
              const latestExisting = existingData.versions[0].version;
              const latestNew = processedReleases[0].version;

              if (compareVersions(latestNew, latestExisting) > 0) {
                console.log(`New release found: ${latestNew} (latest existing: ${latestExisting})`);
                needsUpdate = true;
              } else {
                console.log('No newer releases found. Data is up to date.');
              }
            } else {
              needsUpdate = true;
            }

            if (needsUpdate) {
              if (FORCE_RECREATE) {
                existingData.versions = processedReleases;
              } else {
                // Merge new releases with existing ones
                const existingVersions = new Set(existingData.versions.map(v => v.version));
                const newReleases = processedReleases.filter(r => !existingVersions.has(r.version));

                console.log(`Adding ${newReleases.length} new releases`);

                // Combine and re-sort
                const allVersions = [...newReleases, ...existingData.versions]
                  .map(v => ({ version: v.version, releaseDate: v.releaseDate }))
                  .sort((a, b) => compareVersions(a.version, b.version));

                existingData.versions = allVersions;
              }

              // Limit to most recent 100 versions
              if (existingData.versions.length > 100) {
                console.log(`Limiting to most recent 100 versions (was ${existingData.versions.length})`);
                existingData.versions = existingData.versions.slice(0, 100);
              }

              // Write updated data
              fs.writeFileSync(DATA_FILE, JSON.stringify(existingData, null, 2) + '\n');
              console.log(`âœ… Updated ${DATA_FILE} with ${existingData.versions.length} versions`);
              console.log(`Latest version: ${existingData.versions[0].version} (${existingData.versions[0].releaseDate})`);

              // Set outputs for GitHub Actions
              writeOutput('latest_version', existingData.versions[0].version);
              writeOutput('total_versions', existingData.versions.length);
            } else {
              console.log('â„¹ï¸ No update needed');
            }

          } catch (error) {
            console.error('âŒ Error:', error.message);
            console.error(error.stack);
            process.exit(1);
          }
        }

        main();
        EOF

    - name: Update driver data
      id: update
      env:
        DRIVER_NAME: ${{ inputs.driver_name }}
        DRIVER_DISPLAY_NAME: ${{ inputs.driver_display_name }}
        REPO_NAME: ${{ inputs.repo_name }}
        FORCE_RECREATE: ${{ inputs.force_recreate }}
      run: |
        node update_driver.js

    - name: Check for changes
      id: check_changes
      run: |
        if git diff --quiet data/${{ inputs.driver_name }}.json; then
          echo "No changes detected"
          echo "has_changes=false" >> $GITHUB_OUTPUT
        else
          echo "Changes detected"
          echo "has_changes=true" >> $GITHUB_OUTPUT
        fi

    - name: Commit and push changes
      if: steps.check_changes.outputs.has_changes == 'true'
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add data/${{ inputs.driver_name }}.json
        git commit -m "ðŸ”„ Update ${{ inputs.driver_display_name }} driver data

        - Latest version: ${{ steps.update.outputs.latest_version }}
        - Total versions: ${{ steps.update.outputs.total_versions }}
        - Updated: $(date -u +'%Y-%m-%d %H:%M:%S UTC')

        Auto-updated by GitHub Actions from ${{ inputs.repo_name }}"
        git push
